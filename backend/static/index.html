<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text to Educational Animation</title>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;600;800&family=Inter:wght@300;400&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #050505;
            color: white;
            overflow: hidden; /* background is full-screen; weâ€™ll handle scrolling inside overlay if needed */
        }

        /* Background canvas container */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* Custom spinner */
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spinner 1.5s linear infinite;
            animation: spinner 1.5s linear infinite;
        }

        @keyframes spinner {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="antialiased">

    <!-- 3D Background -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div class="relative z-10 flex items-center justify-center min-h-screen p-4">
        <div class="w-full max-w-2xl bg-gray-800/80 rounded-lg shadow-xl p-8 backdrop-blur-md border border-white/10">
            <h1 class="text-3xl font-bold mb-6 text-center text-blue-400">Text to Educational Animation</h1>

            <div class="mb-6">
                <label for="prompt" class="block text-sm font-medium text-gray-300 mb-2">Describe the animation:</label>
                <textarea id="prompt" rows="3"
                    class="w-full px-3 py-2 bg-gray-700/80 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="e.g., Show me a visual proof of the Pythagorean theorem"></textarea>
            </div>

            <button id="generateBtn"
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded transition duration-200 flex justify-center items-center">
                <span>Generate Animation</span>
            </button>

            <div id="errorContainer"
                class="hidden mt-4 p-4 bg-red-900/50 border border-red-500 rounded text-red-200 text-sm overflow-auto max-h-40">
            </div>

            <div id="videoContainer" class="hidden mt-8">
                <h2 class="text-xl font-semibold mb-3 text-gray-200">Result:</h2>
                <div class="relative pt-[56.25%] bg-black rounded overflow-hidden">
                    <video id="resultVideo" controls class="absolute top-0 left-0 w-full h-full">
                        Your browser does not support the video tag.
                    </video>
                </div>
            </div>
        </div>
    </div>

    <!-- Your existing frontend logic -->
    <script>
        const generateBtn = document.getElementById('generateBtn');
        const promptInput = document.getElementById('prompt');
        const errorContainer = document.getElementById('errorContainer');
        const videoContainer = document.getElementById('videoContainer');
        const resultVideo = document.getElementById('resultVideo');

        generateBtn.addEventListener('click', async () => {
            const prompt = promptInput.value.trim();
            if (!prompt) return;

            // UI Loading State
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-6 w-6 mr-2"></div> Generating...';
            errorContainer.classList.add('hidden');
            videoContainer.classList.add('hidden');

            let data;
            try {
                const response = await fetch('/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ prompt }),
                });

                try {
                    data = await response.json();
                } catch (e) {
                    // Response wasn't JSON (e.g. 500 HTML error page)
                    throw new Error(`Server returned ${response.status} ${response.statusText}`);
                }

                if (!response.ok) {
                    throw new Error(data.error || 'Something went wrong');
                }

                // Success
                resultVideo.src = data.video_url + '?t=' + new Date().getTime(); // Prevent caching
                videoContainer.classList.remove('hidden');
                resultVideo.load();
                resultVideo.play();

            } catch (err) {
                console.error(err);
                errorContainer.textContent = `Error: ${err.message}`;
                if (data && data.details) {
                    errorContainer.textContent += '\n\nDetails:\n' + data.details;
                }
                errorContainer.classList.remove('hidden');
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<span>Generate Animation</span>';
            }
        });
    </script>

    <!-- Three.js background script (taken from Orbit page & trimmed) -->
    <script>
        window.addEventListener('load', () => {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();

            // Subtle fog for depth
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 5;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // --- Starfield ---
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 6000;
            const posArray = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 100;
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

            const sprite = new THREE.TextureLoader().load(
                'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADpJREFUeNpi/P//PwMIMDIy/sfAFDCAESqIAtBFAF0DqtADWlEAFWqA8dEAFWqAcuiALtQAFWqAAgAEDAAdaQwN4Jt96QAAAABJRU5ErkJggg=='
            );

            const starMaterial = new THREE.PointsMaterial({
                size: 0.15,
                map: sprite,
                transparent: true,
                color: 0xffffff,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const starMesh = new THREE.Points(starGeometry, starMaterial);
            scene.add(starMesh);

            // --- Core (Icosahedron + particles) ---
            const geometry = new THREE.IcosahedronGeometry(1.5, 1);

            const materialWire = new THREE.MeshBasicMaterial({
                color: 0x6366f1,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });

            const wireMesh = new THREE.Mesh(geometry, materialWire);

            const materialSolid = new THREE.MeshBasicMaterial({
                color: 0x000000
            });
            const solidMesh = new THREE.Mesh(geometry, materialSolid);

            const coreGroup = new THREE.Group();
            coreGroup.add(wireMesh);
            coreGroup.add(solidMesh);

            const particlesGeo = new THREE.BufferGeometry();
            const particleCount = 200;
            const particlePos = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i++) {
                particlePos[i] = (Math.random() - 0.5) * 5;
            }

            particlesGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));

            const particlesMat = new THREE.PointsMaterial({
                color: 0x00ffff, // fixed from 0xcyan
                size: 0.05,
                transparent: true,
                opacity: 0.8
            });

            const coreParticles = new THREE.Points(particlesGeo, particlesMat);
            coreGroup.add(coreParticles);

            scene.add(coreGroup);

            // --- Lights ---
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0x6366f1, 2, 50);
            pointLight.position.set(2, 2, 2);
            scene.add(pointLight);

            // --- Interaction / Animation ---
            let mouseX = 0;
            let mouseY = 0;
            let targetX = 0;
            let targetY = 0;

            const windowHalfX = window.innerWidth / 2;
            const windowHalfY = window.innerHeight / 2;

            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX - windowHalfX);
                mouseY = (event.clientY - windowHalfY);
            });

            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                const elapsedTime = clock.getElapsedTime();

                // Rotate core
                coreGroup.rotation.y += 0.002;
                coreGroup.rotation.x += 0.001;

                // Pulse wireframe
                const scale = 1 + Math.sin(elapsedTime * 2) * 0.02;
                wireMesh.scale.set(scale, scale, scale);

                // Rotate particles
                coreParticles.rotation.y -= 0.005;

                // Starfield movement
                const positions = starMesh.geometry.attributes.position.array;
                for (let i = 1; i < starCount * 3; i += 3) {
                    positions[i + 1] += 0.1;
                    if (positions[i + 1] > 50) {
                        positions[i + 1] = -50;
                    }
                }
                starMesh.geometry.attributes.position.needsUpdate = true;
                starMesh.rotation.z += 0.0005;

                // Mouse parallax
                targetX = mouseX * 0.001;
                targetY = mouseY * 0.001;

                coreGroup.rotation.y += 0.05 * (targetX - coreGroup.rotation.y);
                coreGroup.rotation.x += 0.05 * (targetY - coreGroup.rotation.x);

                camera.position.x += (mouseX * 0.005 - camera.position.x) * 0.05;
                camera.position.y += (-mouseY * 0.005 - camera.position.y) * 0.05;
                camera.lookAt(scene.position);

                renderer.render(scene, camera);
            }

            animate();

            // Responsive
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        });
    </script>

</body>

</html>
